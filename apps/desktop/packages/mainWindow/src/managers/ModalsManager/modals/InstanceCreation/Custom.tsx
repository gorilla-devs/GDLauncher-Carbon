import { Button, Checkbox, createNotification, Dropdown, Input } from "@gd/ui";
import { ModalProps, useModal } from "../..";
import { Trans, useTransContext } from "@gd/i18n";
import {
  createEffect,
  createMemo,
  createSignal,
  For,
  Match,
  Show,
  Switch
} from "solid-js";
import { port, rspc } from "@/utils/rspcClient";
import {
  CFFEModLoaderType,
  FEModdedManifestLoaderVersion,
  ManifestVersion,
  McType,
  ModLoader
} from "@gd/core_module/bindings";
import { blobToBase64 } from "@/utils/helpers";
import { mcVersions } from "@/utils/mcVersion";
import { useGDNavigate } from "@/managers/NavigationManager";
import { ReactiveMap } from "@solid-primitives/map";

type MappedMcVersions = ManifestVersion & { hasModloader?: boolean };

type Instancetype = {
  id: string;
  modloader: CFFEModLoaderType | undefined;
  title: string | undefined;
  mcVersion: string | undefined;
  modloaderVersion: string | undefined;
  img: string | undefined;
};

// eslint-disable-next-line no-unused-vars
enum Modloaders {
  _Quilt = "quilt",
  _Forge = "forge",
  _NeoForge = "neoforge",
  _Fabric = "fabric"
}

const Custom = (props: Pick<ModalProps, "data">) => {
  const [t] = useTransContext();
  const [mappedMcVersions, setMappedMcVersions] = createSignal<
    MappedMcVersions[]
  >([]);

  const instanceData = () => props.data as Instancetype | undefined;

  const [error, setError] = createSignal("");
  const [bgPreview, setBgPreview] = createSignal<string | null>(
    instanceData()?.img || null
  );
  const [loader, setLoader] = createSignal<CFFEModLoaderType | undefined>(
    instanceData()?.modloader || undefined
  );
  const [loaderVersions, setLoaderVersions] = createSignal<
    FEModdedManifestLoaderVersion[]
  >([]);
  const [chosenLoaderVersion, setChosenLoaderVersion] = createSignal(
    instanceData()?.modloaderVersion || undefined
  );
  const [mcVersion, setMcVersion] = createSignal(
    instanceData()?.mcVersion || ""
  );
  const [customTitle, setCustomTitle] = createSignal<string | null>(null);
  const [snapshotVersionFilter, setSnapshotVersionFilter] = createSignal(false);
  const [oldBetaVersionFilter, setOldBetaVersionFilter] = createSignal(false);
  const [oldAlphaVersionFilter, setOldAlphaVersionFilter] = createSignal(false);

  const autoGeneratedName = () =>
    `${loader() || "Vanilla"} ${
      mcVersion() || (mappedMcVersions()?.[0]?.id as string)
    }`;

  const title = createMemo(() => {
    if (customTitle() !== null) return customTitle();
    if (instanceData()?.title) return instanceData()?.title;

    return autoGeneratedName();
  });

  const forgeHashmap = new ReactiveMap();
  const neoForgeHashmap = new ReactiveMap();
  const fabricHashmap = new ReactiveMap();
  const quiltHashmap = new ReactiveMap();

  const addNotification = createNotification();
  const modalsContext = useModal();
  const navigate = useGDNavigate();

  const forgeVersionsQuery = rspc.createQuery(() => ({
    queryKey: ["mc.getForgeVersions"],
    enabled: false
  }));

  createEffect(() => {
    if (forgeVersionsQuery.isFetched) {
      forgeVersionsQuery.data?.gameVersions.forEach((version) => {
        forgeHashmap.set(version.id, version.loaders);
      });
    }
  });

  const neoForgeVersionsQuery = rspc.createQuery(() => ({
    queryKey: ["mc.getNeoforgeVersions"],
    enabled: false
  }));

  createEffect(() => {
    if (neoForgeVersionsQuery.isFetched) {
      neoForgeVersionsQuery.data?.gameVersions.forEach((version) => {
        neoForgeHashmap.set(version.id, version.loaders);
      });
    }
  });

  const fabricVersionsQuery = rspc.createQuery(() => ({
    queryKey: ["mc.getFabricVersions"],
    enabled: false
  }));

  createEffect(() => {
    if (fabricVersionsQuery.isFetched) {
      fabricVersionsQuery.data?.gameVersions.forEach((version) => {
        fabricHashmap.set(version.id, version.loaders);
      });
    }
  });

  const quiltVersionsQuery = rspc.createQuery(() => ({
    queryKey: ["mc.getQuiltVersions"],
    enabled: false
  }));

  createEffect(() => {
    if (quiltVersionsQuery.isFetched) {
      quiltVersionsQuery.data?.gameVersions.forEach((version) => {
        quiltHashmap.set(version.id, version.loaders);
      });
    }
  });

  const DUMMY_META_VERSION = "${gdlauncher.gameVersion}";

  const isNeoForge = () => loader() === Modloaders._NeoForge;
  const isFabric = () => loader() === Modloaders._Fabric;
  const isForge = () => loader() === Modloaders._Forge;
  const isQuilt = () => loader() === Modloaders._Quilt;

  createEffect(() => {
    if (forgeVersionsQuery.data && isForge()) {
      const versions = forgeVersionsQuery?.data?.gameVersions.find(
        (v) => v.id === (mcVersion() || (mappedMcVersions()?.[0]?.id as string))
      )?.loaders;

      setLoaderVersions(versions || []);
      if (instanceData()?.modloader !== "forge") {
        setChosenLoaderVersion(versions?.[0]?.id);
      } else if (
        instanceData()?.modloader === "forge" &&
        instanceData()?.modloaderVersion
      ) {
        setChosenLoaderVersion(instanceData()?.modloaderVersion);
      }
    } else {
      setLoaderVersions([]);
    }
  });

  createEffect(() => {
    if (neoForgeVersionsQuery.data && isNeoForge()) {
      const versions = neoForgeVersionsQuery?.data?.gameVersions.find(
        (v) => v.id === (mcVersion() || (mappedMcVersions()?.[0]?.id as string))
      )?.loaders;

      setLoaderVersions(versions || []);

      if (instanceData()?.modloader !== "neoforge") {
        setChosenLoaderVersion(versions?.[0]?.id);
      } else if (
        instanceData()?.modloader === "neoforge" &&
        instanceData()?.modloaderVersion
      ) {
        setChosenLoaderVersion(instanceData()?.modloaderVersion);
      }
    } else if (!loader()) {
      setLoaderVersions([]);
    }
  });

  createEffect(() => {
    if (fabricVersionsQuery.data && isFabric()) {
      const supported =
        fabricVersionsQuery?.data?.gameVersions.find(
          (v) =>
            v.id === (mcVersion() || (mappedMcVersions()?.[0]?.id as string))
        ) ?? false;

      const versions =
        supported !== false
          ? fabricVersionsQuery?.data?.gameVersions.find(
              (v) => v.id === DUMMY_META_VERSION
            )?.loaders
          : [];

      setLoaderVersions(versions || []);

      if (instanceData()?.modloader !== "fabric") {
        setChosenLoaderVersion(versions?.[0]?.id);
      } else if (
        instanceData()?.modloader === "fabric" &&
        instanceData()?.modloaderVersion
      ) {
        setChosenLoaderVersion(instanceData()?.modloaderVersion);
      }
    } else if (!loader()) {
      setLoaderVersions([]);
    }
  });

  createEffect(() => {
    if (quiltVersionsQuery.data && isQuilt()) {
      const supported =
        quiltVersionsQuery?.data?.gameVersions.find(
          (v) =>
            v.id === (mcVersion() || (mappedMcVersions()?.[0]?.id as string))
        ) ?? false;

      const versions =
        supported !== false
          ? quiltVersionsQuery?.data?.gameVersions.find(
              (v) => v.id === DUMMY_META_VERSION
            )?.loaders
          : [];

      setLoaderVersions(versions || []);

      if (instanceData()?.modloader !== "quilt") {
        setChosenLoaderVersion(versions?.[0]?.id);
      } else if (
        instanceData()?.modloader === "quilt" &&
        instanceData()?.modloaderVersion
      ) {
        setChosenLoaderVersion(instanceData()?.modloaderVersion);
      }
    } else if (!loader()) {
      setLoaderVersions([]);
    }
  });

  createEffect(() => {
    const filteredData = mcVersions().filter(
      (item) =>
        item.type === "release" ||
        (item.type === "snapshot" && snapshotVersionFilter()) ||
        (item.type === "old_beta" && oldBetaVersionFilter()) ||
        (item.type === "old_alpha" && oldAlphaVersionFilter())
    );

    const neoForgeMappedVersions = filteredData.map((item) => {
      return { ...item, hasModloader: neoForgeHashmap.has(item.id) };
    });
    const forgeMappedVersions = filteredData.map((item) => {
      return { ...item, hasModloader: forgeHashmap.has(item.id) };
    });
    const fabricMappedVersions = filteredData.map((item) => {
      return { ...item, hasModloader: fabricHashmap.has(item.id) };
    });
    const quiltMappedVersions = filteredData.map((item) => {
      return { ...item, hasModloader: quiltHashmap.has(item.id) };
    });

    if (isForge()) setMappedMcVersions(forgeMappedVersions);
    else if (isNeoForge()) setMappedMcVersions(neoForgeMappedVersions);
    else if (isFabric()) setMappedMcVersions(fabricMappedVersions);
    else if (isQuilt()) setMappedMcVersions(quiltMappedVersions);
    else setMappedMcVersions(filteredData);

    if (!mcVersion() || !mappedMcVersions().find((v) => v.id === mcVersion())) {
      setMcVersion(mappedMcVersions()[0].id);
    }
  });

  const modloaders: {
    label: string;
    key: CFFEModLoaderType | undefined;
  }[] = [
    { label: t("instance.vanilla"), key: undefined },
    { label: t("instance.forge"), key: "forge" },
    { label: t("instance.neoforge"), key: "neoforge" },
    { label: t("instance.fabric"), key: "fabric" },
    { label: t("instance.quilt"), key: "quilt" }
  ];

  const defaultGroup = rspc.createQuery(() => ({
    queryKey: ["instance.getDefaultGroup"]
  }));

  const prepareInstanceMutation = rspc.createMutation(() => ({
    mutationKey: ["instance.prepareInstance"]
  }));

  const createInstanceMutation = rspc.createMutation(() => ({
    mutationKey: ["instance.createInstance"]
  }));

  const updateInstanceMutation = rspc.createMutation(() => ({
    mutationKey: ["instance.updateInstance"]
  }));

  const mapTypeToColor = (
    type: McType,
    hasNoModloader: boolean | undefined
  ) => {
    return (
      <Switch>
        <Match when={type === "release"}>
          <span
            class="text-green-500"
            classList={{ "opacity-50": hasNoModloader }}
          >{`[${type}]`}</span>
        </Match>
        <Match when={type === "snapshot"}>
          <span
            class="text-yellow-500"
            classList={{ "opacity-50": hasNoModloader }}
          >{`[${type}]`}</span>
        </Match>
        <Match when={type === "old_alpha"}>
          <span
            class="text-purple-500"
            classList={{ "opacity-50": hasNoModloader }}
          >{`[${type}]`}</span>
        </Match>
        <Match when={type === "old_beta"}>
          <span
            class="text-red-500"
            classList={{ "opacity-50": hasNoModloader }}
          >{`[${type}]`}</span>
        </Match>
      </Switch>
    );
  };

  const loadIcon = (filePaths: string) => {
    fetch(`http://127.0.0.1:${port}/instance/loadIcon?path=${filePaths}`).then(
      async (img) => {
        const blob = await img.blob();
        const b64 = (await blobToBase64(blob)) as string;

        setBgPreview(
          `data:image/png;base64, ${b64.substring(b64.indexOf(",") + 1)}`
        );
      }
    );
  };

  const isNameDiff = () => title() && title() !== instanceData()?.title;
  const isMcVersionDiff = () =>
    mcVersion() && mcVersion() !== instanceData()?.mcVersion;
  const isModloaderDiff = () => loader() !== instanceData()?.modloader;
  const isModloaderVersionDiff = () =>
    chosenLoaderVersion() !== instanceData()?.modloaderVersion;
  const isIconDiff = () => bgPreview() !== instanceData()?.img; // not checking for null as it can be unset

  const isUpdatingWithDiffs = () => {
    if (!instanceData()) return true;

    return (
      isNameDiff() ||
      isMcVersionDiff() ||
      isModloaderDiff() ||
      isModloaderVersionDiff() ||
      isIconDiff()
    );
  };

  const handleCreate = async () => {
    if (!title()) {
      setError("Fields must be filled in!");
    } else {
      setError("");

      try {
        const instanceId = await createInstanceMutation.mutateAsync({
          group: defaultGroup.data || 1,
          use_loaded_icon: true,
          notes: "",
          name: title()!,
          version: {
            Version: {
              Standard: {
                release: mcVersion() || (mappedMcVersions()?.[0]?.id as string),
                modloaders: loader()
                  ? [
                      {
                        type_: loader() as CFFEModLoaderType,
                        version: chosenLoaderVersion() || loaderVersions()[0].id
                      } as ModLoader
                    ]
                  : []
              }
            }
          }
        });

        await prepareInstanceMutation.mutateAsync(instanceId);

        modalsContext?.closeModal();
        navigate(`/library`);
        addNotification({
          name: "Instance successfully created.",
          type: "success"
        });
      } catch (err) {
        console.error(err);
        modalsContext?.closeModal();
        addNotification({
          name: "Error while creating the instance.",
          type: "error"
        });
      } finally {
        setError("");
        setCustomTitle("");
        setError("");
        setBgPreview(null);
        setMcVersion("");
        setChosenLoaderVersion("");
      }
    }
  };

  const handleUpdate = async () => {
    if (!title()) {
      setError("Fields must be filled in!");
      return;
    }

    if (instanceData()?.id) {
      setError("");

      try {
        await updateInstanceMutation.mutateAsync({
          instance: parseInt((instanceData() as Instancetype).id, 10),
          useLoadedIcon: isIconDiff() ? { Set: Boolean(bgPreview()) } : null,
          name: isNameDiff() ? { Set: title()! } : null,
          version: isMcVersionDiff()
            ? {
                Set: mcVersion() || (mappedMcVersions()?.[0]?.id as string)
              }
            : null,
          modloader:
            isModloaderDiff() || isModloaderVersionDiff()
              ? {
                  Set: loader()
                    ? ({
                        type_: loader() as CFFEModLoaderType,
                        version: chosenLoaderVersion() || loaderVersions()[0].id
                      } as ModLoader)
                    : null
                }
              : null
        });

        modalsContext?.closeModal();
        addNotification({
          name: "Instance successfully updated.",
          type: "success"
        });
      } catch (err) {
        console.error(err);
        modalsContext?.closeModal();
        addNotification({
          name: "Error while creating the instance.",
          type: "error"
        });
      } finally {
        setError("");
        setCustomTitle("");
        setError("");
        setBgPreview(null);
        setMcVersion("");
        setChosenLoaderVersion("");
      }
    }
  };

  createEffect(() => {
    if (instanceData()?.modloader === "forge") {
      forgeVersionsQuery.refetch();
    } else if (instanceData()?.modloader === "neoforge") {
      neoForgeVersionsQuery.refetch();
    } else if (instanceData()?.modloader === "fabric") {
      fabricVersionsQuery.refetch();
    } else if (instanceData()?.modloader === "quilt") {
      quiltVersionsQuery.refetch();
    }
  });

  return (
    <div class="flex flex-col justify-between h-full w-full">
      <div class="flex flex-col justify-between gap-4 h-full p-5">
        <div class="flex flex-col justify-between gap-4">
          <div class="flex items-center w-full">
            <div
              class={`flex-1 border-t-1 border-lightSlate-400 border-solid`}
            />
            <span
              class={`px-3 flex text-lightSlate-400 items-center gap-2 text-xl`}
            >
              <Trans key="general.about" />
            </span>
            <div
              class={`flex-1 border-t-1 border-lightSlate-400 border-solid`}
            />
          </div>
          <div class="flex gap-4 w-full">
            <div
              class="relative flex justify-center items-center bg-darkSlate-800 bg-center bg-cover h-20 rounded-xl w-20 box-border outline-none hover:outline-darkSlate-600 transition-all ease-in-out duration-200"
              style={{
                ...(bgPreview() && {
                  "background-image": `url("${bgPreview()}")`
                })
              }}
              onClick={() => {
                window
                  .openFileDialog({
                    title: "Select Icon",
                    filters: [
                      { name: "Image", extensions: ["png", "jpg", "jpeg"] }
                    ]
                  })
                  .then((files) => {
                    if (!files.filePaths[0]) return;
                    loadIcon(files.filePaths[0]);
                  });
              }}
            >
              <Switch>
                <Match when={!bgPreview()}>
                  <h3 class="text-center">
                    <Trans key="instance.select_image" />
                  </h3>
                </Match>
                <Match when={bgPreview()}>
                  <div class="absolute top-0 right-0 pb-2 pl-2 bg-darkSlate-700 rounded-bl-2xl">
                    <div
                      class="text-lightSlate-50 transition-all duration-100 ease-in-out text-lg i-ri:close-circle-fill hover:color-red-500"
                      onClick={(e) => {
                        e.preventDefault();
                        setBgPreview(null);
                      }}
                    />
                  </div>
                </Match>
              </Switch>
            </div>
            <div class="flex-1">
              <div class="mt-0 mb-2 text-sm">
                <Trans key="instance.instance_name" />
              </div>
              <div class="flex gap-4 items-center flex-1 w-full">
                <Input
                  class="w-full"
                  required
                  placeholder={t("instance.new_instance")}
                  inputColor="bg-darkSlate-800"
                  onInput={(e) => {
                    setCustomTitle(e.currentTarget.value);
                  }}
                  value={title()!}
                  error={
                    error() &&
                    !title() &&
                    (t("error.missing_field_title") as string)
                  }
                />
              </div>
            </div>
          </div>
          <div class="flex items-center w-full">
            <div
              class={`flex-1 border-t-1 border-lightSlate-400 border-solid`}
            />
            <span
              class={`px-3 flex text-lightSlate-400 items-center gap-2 text-xl`}
            >
              <Trans key="instance.instance_mc_version" />
            </span>
            <div
              class={`flex-1 border-t-1 border-lightSlate-400 border-solid`}
            />
          </div>
          <div>
            <div class="flex gap-6 w-full items-center">
              <div class="flex flex-col gap-2 mt-2 min-w-24">
                <div class="flex gap-2 items-center">
                  <Checkbox
                    checked={snapshotVersionFilter()}
                    onChange={(e) => setSnapshotVersionFilter(e)}
                  />
                  <h6 class="m-0 flex items-center">
                    <Trans key="instance.instance_version_snapshot" />
                  </h6>
                </div>
                <div class="flex gap-2">
                  <Checkbox
                    checked={oldAlphaVersionFilter()}
                    onChange={(e) => setOldAlphaVersionFilter(e)}
                  />
                  <h6 class="m-0 flex items-center">
                    <Trans key="instance.instance_version_old_alpha" />
                  </h6>
                </div>
                <div class="flex gap-2">
                  <Checkbox
                    checked={oldBetaVersionFilter()}
                    onChange={(e) => setOldBetaVersionFilter(e)}
                  />
                  <h6 class="m-0 flex items-center">
                    <Trans key="instance.instance_version_old_beta" />
                  </h6>
                </div>
              </div>
              <Dropdown
                disabled={Boolean(
                  ((forgeVersionsQuery.isFetching ||
                    fabricVersionsQuery.isFetching ||
                    quiltVersionsQuery.isFetching ||
                    neoForgeVersionsQuery.isFetching) &&
                    loader()) ||
                    mappedMcVersions().length === 0
                )}
                options={mappedMcVersions().map((v) => ({
                  label: (
                    <div
                      class="flex justify-between w-full"
                      classList={{
                        "text-darkSlate-500": Boolean(
                          !v.hasModloader && loader()
                        )
                      }}
                    >
                      <span>{v.id}</span>
                      {mapTypeToColor(
                        v.type,
                        Boolean(!v.hasModloader && loader())
                      )}
                    </div>
                  ),
                  key: v.id
                }))}
                bgColorClass="bg-darkSlate-800"
                containerClass="w-full"
                class="w-full"
                placeholder={t("error.no_mc_versions")}
                placement="bottom"
                value={mcVersion()}
                onChange={(l) => {
                  setMcVersion(l.key as string);

                  if (!loader) {
                    setLoaderVersions([]);
                  } else if (isForge()) {
                    const versions =
                      forgeVersionsQuery?.data?.gameVersions.find(
                        (v) => v.id === l.key
                      )?.loaders;

                    setLoaderVersions(versions || []);
                  } else if (isNeoForge()) {
                    const versions =
                      neoForgeVersionsQuery?.data?.gameVersions.find(
                        (v) => v.id === l.key
                      )?.loaders;

                    setLoaderVersions(versions || []);
                  } else if (isFabric()) {
                    const supported =
                      fabricVersionsQuery?.data?.gameVersions.find(
                        (v) => v.id === l.key
                      ) ?? false;

                    const versions =
                      supported !== false
                        ? fabricVersionsQuery?.data?.gameVersions.find(
                            (v) => v.id === DUMMY_META_VERSION
                          )?.loaders
                        : [];

                    setLoaderVersions(versions || []);
                  } else if (isQuilt()) {
                    const supported =
                      quiltVersionsQuery?.data?.gameVersions.find(
                        (v) => v.id === l.key
                      ) ?? false;

                    const versions =
                      supported !== false
                        ? quiltVersionsQuery?.data?.gameVersions.find(
                            (v) => v.id === DUMMY_META_VERSION
                          )?.loaders
                        : [];

                    setLoaderVersions(versions || []);
                  }
                }}
              />
            </div>
          </div>
          <div class="flex items-center w-full">
            <div
              class={`flex-1 border-t-1 border-lightSlate-400 border-solid`}
            />
            <span
              class={`px-3 flex text-lightSlate-400 items-center gap-2 text-xl`}
            >
              <Trans key="general.modloader" />
            </span>
            <div
              class={`flex-1 border-t-1 border-lightSlate-400 border-solid`}
            />
          </div>
          <div class="flex gap-2 w-full justify-center">
            <For each={modloaders}>
              {(modloader) => (
                <div
                  class="px-3 py-2 bg-darkSlate-800 rounded-lg border-box text-darkSlate-50 hover:text-lightSlate-50"
                  classList={{
                    "hover:outline-darkSlate-600 outline-none":
                      loader() !== modloader.key,
                    "outline-primary-500 outline text-lightSlate-50":
                      loader() === modloader.key
                  }}
                  onClick={() => {
                    if (modloader.key === "forge") {
                      forgeVersionsQuery.refetch();
                    } else if (modloader.key === "neoforge") {
                      neoForgeVersionsQuery.refetch();
                    } else if (modloader.key === "fabric") {
                      fabricVersionsQuery.refetch();
                    } else if (modloader.key === "quilt") {
                      quiltVersionsQuery.refetch();
                    }

                    setLoader(
                      !modloader.key
                        ? undefined
                        : (modloader.key as CFFEModLoaderType)
                    );
                  }}
                >
                  {modloader.label}
                </div>
              )}
            </For>
          </div>
          <Show when={loader()}>
            <div>
              <h5 class="mt-0 mb-2">
                <Trans key="instance.instance_loader_version" />
              </h5>
              <Switch>
                <Match when={loaderVersions().length > 0}>
                  <Dropdown
                    disabled={
                      forgeVersionsQuery.isFetching ||
                      fabricVersionsQuery.isFetching ||
                      quiltVersionsQuery.isFetching ||
                      neoForgeVersionsQuery.isFetching ||
                      !loaderVersions()
                    }
                    options={loaderVersions()?.map((v) => ({
                      label: v.id,
                      key: v.id
                    }))}
                    bgColorClass="bg-darkSlate-800"
                    containerClass="w-full"
                    class="w-full"
                    value={chosenLoaderVersion()}
                    placement="bottom"
                    onChange={(l) => {
                      const key = l.key as string;
                      if (key) {
                        setChosenLoaderVersion(key);
                      }
                    }}
                  />
                </Match>
                <Match when={loaderVersions().length === 0}>
                  <Dropdown
                    disabled
                    options={[{ label: "No elements", key: "none" }]}
                    bgColorClass="bg-darkSlate-800"
                    containerClass="w-full"
                    class="w-full"
                    value={"none"}
                    placement="bottom"
                  />
                </Match>
              </Switch>
            </div>
          </Show>
        </div>
        <div class="flex w-full justify-between">
          <Button
            type="secondary"
            style={{ width: "100%", "max-width": "200px" }}
            onClick={() => modalsContext?.closeModal()}
          >
            <Trans
              key="instance.instance_modal_instance_creation_cancel"
              options={{
                defaultValue: "Cancel"
              }}
            />
          </Button>
          <Button
            disabled={Boolean(
              (loaderVersions().length === 0 && loader()) ||
                mappedMcVersions().length === 0 ||
                !isUpdatingWithDiffs()
            )}
            type="primary"
            style={{ width: "100%", "max-width": "200px" }}
            onClick={() => {
              if (instanceData()) handleUpdate();
              else handleCreate();
            }}
          >
            <Switch>
              <Match when={!instanceData()}>
                <Trans
                  key="instance.instance_modal_instance_creation_create"
                  options={{
                    defaultValue: "Create"
                  }}
                />
              </Match>
              <Match when={instanceData()}>
                <Trans key="instance.instance_modal_instance_update" />
              </Match>
            </Switch>
          </Button>
        </div>
      </div>
    </div>
  );
};

export default Custom;
